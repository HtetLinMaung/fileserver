import axios from "axios";

export interface FileChunk {
  hash: number;
  chunk: any;
}

export const pickFile = async (options: any = {}): Promise<any> => {
  return new Promise((resolve, reject) => {
    try {
      const element = document.createElement("input");
      element.type = "file";
      element.click();
      element.addEventListener("change", (e: any) => {
        const file = e.target.files[0];
        element.value = "";
        resolve(file);
      });
    } catch (err) {
      reject(err);
    }
  });
};

const splitFileChunks = (file: any, size: number = 1024 * 50) => {
  //50KB Section size default
  const fileChunks: FileChunk[] = [];
  let index = 0; //Section num
  for (let cur = 0; cur < file.size; cur += size) {
    fileChunks.push({
      hash: index++,
      chunk: file.slice(cur, cur + size),
    });
  }
  return fileChunks;
};

export const uploadFileChunks = async (mergeUrl: string, uploadUrl: string) => {
  const file = await pickFile();
  return uploadChunks(mergeUrl, uploadUrl, file.name, splitFileChunks(file));
};

const uploadChunks = async (
  mergeUrl: string,
  uploadUrl: string,
  filename: string,
  list: FileChunk[] = [],
  token: string = ""
) => {
  if (list.length === 0) {
    //All tasks complete, merge slices
    await axios({
      method: "get",
      url: mergeUrl,
      params: {
        filename,
      },
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });
    console.log("Upload to complete");
    return;
  }

  let pool: any[] = []; //Concurrent pool
  let max = 3; //Maximum concurrency
  let finish = 0; //Quantity completed
  let failList: any[] = []; //A list of failures
  for (let i = 0; i < list.length; i++) {
    let item = list[i];
    let formData = new FormData();
    formData.append("filename", filename);
    formData.append("hash", item.hash.toString());
    formData.append("chunk", item.chunk);
    // Upload section
    let task = axios({
      method: "post",
      url: uploadUrl,
      data: formData,
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });
    task
      .then((data) => {
        //Remove the Promise task from the concurrency pool when the request ends
        let index = pool.findIndex((t) => t === task);
        pool.splice(index);
      })
      .catch(() => {
        failList.push(item);
      })
      .finally(() => {
        finish++;
        //All requests are requested complete
        if (finish === list.length) {
          uploadChunks(mergeUrl, uploadUrl, filename, failList);
        }
      });
    pool.push(task);
    if (pool.length === max) {
      //Each time the concurrent pool finishes running a task, another task is plugged in
      await Promise.race(pool);
    }
  }
};
